<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>第一章  神经网络计算过程及介绍 | BLOG</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://perfectqing.github.io/blogs/favicon.ico?v=1626771437070">
<link rel="stylesheet" href="https://perfectqing.github.io/blogs/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="👏  第一章  神经网络计算过程及介绍
✍️  本讲目标：学会神经网络计算过程，使用基于TF2原生代码搭建你的第一个神经网络训练模型。

第一章  神经网络计算过程及介绍
本讲目标：学会神经网络计算过程，使用基于TF2原生代码搭建你的第一..." />
    <meta name="keywords" content="TensorFlow 笔记" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://perfectqing.github.io/blogs">
        <img src="https://perfectqing.github.io/blogs/images/avatar.png?v=1626771437070" class="site-logo">
        <h1 class="site-title">BLOG</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Carry on what you want...
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> Copyright © AlsoRan | <a class="rss" href="https://perfectqing.github.io/blogs/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">第一章  神经网络计算过程及介绍</h2>
            <div class="post-date">2021-07-12</div>
            
              <div class="feature-container" style="background-image: url('https://perfectqing.github.io/blogs/post-images/hello-gridea.png')">
              </div>
            
            <div class="post-content" v-pre>
              <p>👏  第一章  神经网络计算过程及介绍<br>
✍️  本讲目标：学会神经网络计算过程，使用基于TF2原生代码搭建你的第一个神经网络训练模型。</p>
<!-- more -->
<h2 id="第一章-神经网络计算过程及介绍">第一章  神经网络计算过程及介绍</h2>
<p>本讲目标：学会神经网络计算过程，使用基于TF2原生代码搭建你的第一个神经网络训练模型。</p>
<p>人工智能：让机器具备人的思维和意识。</p>
<h3 id="11-人工智能三学派">1.1 人工智能三学派</h3>
<ul>
<li>行为主义：基于控制论，构建感知-动作控制系统。（控制论，如平衡、行走、避障等自适应控制系统）</li>
<li>符号主义：基于算数逻辑表达式，求解问题时先把问题描述为表达式，再求解表达式。（可用公式描述、实现理性思维，如专家系系统）</li>
<li>连接主义：仿生学，模仿神经元连接关系。（仿脑神经元连接，实现感性思维，如神经网络）</li>
</ul>
<h3 id="12-神经网络的设计过程">1.2 神经网络的设计过程</h3>
<ol>
<li>
<h4 id="鸢尾花分类iris">鸢尾花分类（Iris）</h4>
<pre><code>0  狗尾草鸢尾
1  杂色鸢尾
2  佛吉尼亚鸢尾
</code></pre>
<ul>
<li>简化模型：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi><mo>×</mo><mi>w</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y=x\times w+ b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></li>
<li>均方误差：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>E</mi><mo>(</mo><mi>y</mi><mo separator="true">,</mo><msub><mi>y</mi><mi mathvariant="normal">_</mi></msub><mo>)</mo><mo>=</mo><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><mo>(</mo><mi>y</mi><mo>−</mo><msub><mi>y</mi><mi mathvariant="normal">_</mi></msub><msup><mo>)</mo><mn>2</mn></msup></mrow><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">MSE(y,y_\_)=\frac{\sum_{k=0}^n(y-y_\_)^2}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.117em;vertical-align:-0.367em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.065608em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight" style="margin-right:0.02778em;">_</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.53402em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.18902em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5651em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.05688571428571432em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight" style="margin-right:0.02778em;">_</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.36442857142857144em;"><span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
</ul>
</li>
<li>
<h4 id="用神经网络实现鸢尾花分类梯度下降">用神经网络实现鸢尾花分类：梯度下降</h4>
<ul>
<li>目的：找到一组参数w和b，使得损失函数最小。</li>
<li>梯度：函数对各参数求偏导后的向量。函数梯度下降方向是函数减小方向。</li>
<li>梯度下降法：沿损失函数梯度下降的方向，寻找损失函数的最小值，得到最优参数的方法。</li>
</ul>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \part at position 26: …t - lr * \frac{\̲p̲a̲r̲t̲ ̲loss}{\part w_t…'>w_{t+1}=w_t - lr * \frac{\part loss}{\part w_t}\\
b_{t+1} = b_t -  lr * \frac{\part loss}{\part b_t}\\
w_{t+1} * x + b_{t+1} = y
</p>
<ul>
<li>学习率（learning rate， lr）：当学习率设置的过小时，收敛过程将变得十分缓慢。而当学习率设置的过大时，梯度可能会在最小值附近来回震荡，甚至可能无法收敛。</li>
</ul>
</li>
<li>
<h4 id="用神经网络实现鸢尾花分类反向传播">用神经网络实现鸢尾花分类：反向传播</h4>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \part at position 26: …t - lr * \frac{\̲p̲a̲r̲t̲ ̲loss}{\part w_t…'>w_{t+1}=w_t - lr * \frac{\part loss}{\part w_t}
</p>
<ul>
<li>反向传播：从后向前，逐层求损失函数对每层神经元参数的偏导数，迭代更新所有参数。</li>
<li>eg：损失函数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo>=</mo><mo>(</mo><mi>w</mi><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">loss=(w+1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>,  <span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \part at position 7: \frac{\̲p̲a̲r̲t̲ ̲loss}{\part w}=…'>\frac{\part loss}{\part w}=2w+2</span></li>
</ul>
<pre><code>参数初始化为5，学习率为0.2，则
1次  参数w:5      5-0.2*(2*5+2)=2.6
2次  参数w:2.6    2.6-0.2*(2*2.6+2)=1.16
3次  参数w:1.16   1.16-0.2*(2*1.16+2)=0.296
4次  参数w:0.296
......
</code></pre>
<ul>
<li>Code  p13_backpropagation.py</li>
</ul>
<pre><code class="language-python">import tensorflow as tf

w = tf.Variable(tf.constant(5, dtype=tf.float32))
lr = 0.2
epoch = 40

for epoch in range(epoch):  # for epoch 定义顶层循环，表示对数据集循环epoch次，此例数据集数据仅有1个w,初始化时候constant赋值为5，循环40次迭代。
    with tf.GradientTape() as tape:  # with结构到grads框起了梯度的计算过程。
        loss = tf.square(w + 1)
    grads = tape.gradient(loss, w)  # .gradient函数告知谁对谁求导

    w.assign_sub(lr * grads)  # .assign_sub 对变量做自减 即：w -= lr*grads 即 w = w - lr*grads
    print(&quot;After %s epoch,w is %f,loss is %f&quot; % (epoch, w.numpy(), loss))

# lr初始值：0.2   请自改学习率  0.001  0.999 看收敛过程
# 最终目的：找到 loss 最小 即 w = -1 的最优参数w

</code></pre>
</li>
</ol>
<h3 id="13-张量生成">1.3 张量生成</h3>
<ul>
<li>
<p>**张量（Tensor）：**多维数组（列表）  阶：张量的维数</p>
<table>
<thead>
<tr>
<th style="text-align:center">维数</th>
<th style="text-align:center">阶</th>
<th style="text-align:left">名字</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0-D</td>
<td style="text-align:center">0</td>
<td style="text-align:left">标量 scalar</td>
<td>s=1 2 3</td>
</tr>
<tr>
<td style="text-align:center">1-D</td>
<td style="text-align:center">1</td>
<td style="text-align:left">向量 vector</td>
<td>v=[1, 2, 3]</td>
</tr>
<tr>
<td style="text-align:center">2-D</td>
<td style="text-align:center">2</td>
<td style="text-align:left">矩阵 matrix</td>
<td>m=[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</td>
</tr>
<tr>
<td style="text-align:center">n-D</td>
<td style="text-align:center">n</td>
<td style="text-align:left">张量 tensor</td>
<td>t=[[[    n个</td>
</tr>
</tbody>
</table>
<p>张量可以表示0阶到n阶数组（列表）</p>
</li>
<li>
<p>数据类型</p>
<ul>
<li>
<p>tf.int, tf.float ......</p>
<p>tf.int32, tf.float32, tf.float64</p>
</li>
<li>
<p>tf.bool</p>
<p>tf.constant([True, False])</p>
</li>
<li>
<p>tf.string</p>
<p>tf.constant(&quot;hello, world!&quot;)</p>
</li>
</ul>
</li>
<li>
<p>如何创建一个Tensor</p>
<p>创建一个张量<br>
tf.constant(张量内容, dtype=数据类型(可选))</p>
<pre><code class="language-python">import tensorflow as tf

a = tf.constant([1, 5], dtype=tf.int64)
print(a)
print(a.dtype)
print(a.shape)

# 运行结果
# tf.Tensor([1 5], shape=(2,), dtype=int64)
# &lt;dtype: 'int64'&gt;
# (2,)  一维张量，含有两个元素
</code></pre>
</li>
<li>
<p>将numpy的数据类型转换为Tensor数据类型</p>
<p>tf.convert_to_tensor(数据名, dtype=数据类型(可选))</p>
<pre><code class="language-python">import tensorflow as tf
import numpy as np
a = np.arange(0, 5)
b = tf.convert_to_tensor(a, dtype=tf.int64)
print(a)
print(b)

# 运行结果
# [0 1 2 3 4]
# tf.Tensor([0 1 2 3 4], shape=(5,), dtype=int64)
</code></pre>
</li>
<li>
<p>创建全为0的张量</p>
<p>tf.zeros(维度)</p>
</li>
<li>
<p>创建全为1的张量</p>
<p>tf.ones(维度)</p>
</li>
<li>
<p>创建全为指定维度的张量</p>
<p>tf.fill(维度, 指定值)</p>
<p>维度：一维直接写个数，二维用[行, 列]，多为用[n, m, j, k ......]</p>
<pre><code class="language-python">import tensorflow as tf

a = tf.zeros([2, 3])
b = tf.ones(4)
c = tf.fill([2, 2], 9)
print(a)
print(b)
print(c)

# 运行结果
# tf.Tensor(
# [[0. 0. 0.]
#  [0. 0. 0.]], shape=(2, 3), dtype=float32)
# tf.Tensor([1. 1. 1. 1.], shape=(4,), dtype=float32)
# tf.Tensor(
# [[9 9]
#  [9 9]], shape=(2, 2), dtype=int32)
</code></pre>
</li>
<li>
<p>生成正态分布的随机数, 默认均值为0, 标准差为1</p>
<p>tf.random.normal(维度, mean=均值, stddev=标准差)</p>
</li>
<li>
<p>生成截断式正态分布的随机数</p>
<p>tf.random.truncated_normal(维度, mean=均值, stddev=标准差)</p>
<p>在tf.truncated_normal中如果随机生成数据的取值在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>μ</mi><mo>−</mo><mn>2</mn><mi>δ</mi><mo separator="true">,</mo><mi>μ</mi><mo>+</mo><mn>2</mn><mi>δ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(\mu-2\delta,\mu+2\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span> 之外则重新进行生成，保证了生成值在均值附近。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span></span></span></span>：均值，  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>：标准差<br>
标准差计算公式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>=</mo><msqrt><mfrac><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mover accent="true"><mi>x</mi><mo>ˉ</mo></mover><mo>)</mo></mrow><mi>n</mi></mfrac></msqrt></mrow><annotation encoding="application/x-tex">\delta=\sqrt{\frac{\sum_{i=1}^n (x_i-\bar x)}{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.4974965em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3425035em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.060007em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5350070000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop op-symbol small-op mtight" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7046857142857144em;"><span style="top:-2.1785614285714283em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.8971428571428572em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32143857142857146em;"><span></span></span></span></span></span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.56778em;"><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord mathdefault mtight">x</span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span class="accent-body" style="left:-0.22222em;"><span class="mtight">ˉ</span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.3025035em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M1001,80H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,
572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,
-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39
c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60
s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,
-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5c4,-6.7,10,-10,18,-10z
M1001 80H400000v40H1013z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4974965em;"><span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-python">import tensorflow as tf

d = tf.random.normal([2, 2], mean=0.5, stddev=1)
print(&quot;d:&quot;, d)
e = tf.random.truncated_normal([2, 2], mean=0.5, stddev=1)
print(&quot;e:&quot;, e)

# 运行结果
# d: tf.Tensor(
# [[ 1.9877443  -1.2797751 ]
#  [ 1.6146473   0.39082623]], shape=(2, 2), dtype=float32)
# e: tf.Tensor(
# [[ 1.3543694   1.0639844 ]
#  [-0.9956173  -0.16789067]], shape=(2, 2), dtype=float32)
</code></pre>
</li>
<li>
<p>生成均匀分布随机数 [minval, maxval]</p>
<p>tf.random.uniform(维度, minval=最小值, maxval=最大值)</p>
<pre><code class="language-python">import tensorflow as tf

f = tf.random.uniform([2, 2], minval=0, maxval=1)
print(&quot;f:&quot;, f)

# 运行结果
# f: tf.Tensor(
# [[0.78154075 0.5844718 ]
#  [0.6193285  0.62899697]], shape=(2, 2), dtype=float32)
</code></pre>
</li>
</ul>
<h3 id="14-常用函数">1.4 常用函数</h3>
<ul>
<li>
<p>强制tensor转换为该数据类型</p>
<p>tf.cast(张量名, dtype=数据类型)</p>
</li>
<li>
<p>计算张量维度上元素的最小值</p>
<p>tf.reduce_min(张量名)</p>
</li>
<li>
<p>计算张量维度上的最大值</p>
<p>tf.reduce_max(张量名)</p>
</li>
</ul>
<pre><code class="language-python">import tensorflow as tf

x1 = tf.constant([1., 2., 3.], dtype=tf.float64)
print(&quot;x1:&quot;, x1)
x2 = tf.cast(x1, tf.int32)
print(&quot;x2&quot;, x2)
print(&quot;minimum of x2：&quot;, tf.reduce_min(x2))
print(&quot;maxmum of x2:&quot;, tf.reduce_max(x2))

# 运行结果
# x1: tf.Tensor([1. 2. 3.], shape=(3,), dtype=float64)
# x2 tf.Tensor([1 2 3], shape=(3,), dtype=int32)
# minimum of x2： tf.Tensor(1, shape=(), dtype=int32)
# maxmum of x2: tf.Tensor(3, shape=(), dtype=int32)
</code></pre>
<ul>
<li>
<p>理解axis</p>
<p>在一个二位张量或者数组中，可以通过调整axis等于0或1控制执行维度。</p>
<ul>
<li>axis=0代表跨行（经度，down），而axis=1代表跨列（纬度，across）</li>
<li>如果不指定axis，则所有元素参与计算</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://images.cnblogs.com/cnblogs_com/ache/1998711/o_2107111240321-1.png" alt="image-20210710134643046" loading="lazy"></figure>
<ul>
<li>
<p>计算张量沿指定维度的平均值</p>
<p>tf.reduce_mean(张量名, axis=操作轴)</p>
</li>
<li>
<p>计算张量沿着指定维度的和</p>
<p>tf.reduce_sum(张量名, axis=操作轴)</p>
</li>
</ul>
<pre><code class="language-python">import tensorflow as tf

x = tf.constant([[1, 2, 3], [2, 2, 3]])
print(&quot;x:&quot;, x)
print(&quot;mean of x:&quot;, tf.reduce_mean(x))  # 求x中所有数的均值
print(&quot;mean of x by rows:&quot;, tf.reduce_mean(x, axis=0))  # 求x中每一行数的均值
print(&quot;sum of x:&quot;, tf.reduce_sum(x, axis=1))  # 求每一行的和

# 运行结果
# x: tf.Tensor(
# [[1 2 3]
#  [2 2 3]], shape=(2, 3), dtype=int32)
# mean of x: tf.Tensor(2, shape=(), dtype=int32)
# mean of x by rows: tf.Tensor([1 2 3], shape=(3,), dtype=int32)
# sum of x: tf.Tensor([6 7], shape=(2,), dtype=int32)
</code></pre>
<ul>
<li>
<p>tf.Variable</p>
<p>tf.Variable() 将变量标记为“可训练”，<strong>被标记的变量会在反向传播中记录梯度信息</strong>。神经网络训练中，常用该函数标记待训练参数。<br>
tf.Variable(初始值)<br>
w = tf.Variable(tf.random.normal([2, 2], mean=0, stddev=1))</p>
</li>
<li>
<p>TensorFlow中的数学运算</p>
<ul>
<li>
<p><strong>对应元素</strong>的四则运算：tf.add, tf.subtract, tf.multiply, tf.divide</p>
<p>tf.add(张量1, 张量2)</p>
<pre><code class="language-python">import tensorflow as tf

a = tf.ones([1, 3])
b = tf.fill([1, 3], 3.)
print(&quot;a:&quot;, a)
print(&quot;b:&quot;, b)
print(&quot;a+b:&quot;, tf.add(a, b))
print(&quot;a-b:&quot;, tf.subtract(a, b))
print(&quot;a*b:&quot;, tf.multiply(a, b))
print(&quot;b/a:&quot;, tf.divide(b, a))

# 运行结果
# a: tf.Tensor([[1. 1. 1.]], shape=(1, 3), dtype=float32)
# b: tf.Tensor([[3. 3. 3.]], shape=(1, 3), dtype=float32)
# a+b: tf.Tensor([[4. 4. 4.]], shape=(1, 3), dtype=float32)
# a-b: tf.Tensor([[-2. -2. -2.]], shape=(1, 3), dtype=float32)
# a*b: tf.Tensor([[3. 3. 3.]], shape=(1, 3), dtype=float32)
# b/a: tf.Tensor([[3. 3. 3.]], shape=(1, 3), dtype=float32)
</code></pre>
</li>
<li>
<p>平方、次方与开方：tf.square, tf.pow, tf.sqrt</p>
<p>tf.square(张量名)  # 计算某个张量的平方<br>
tf.pow(张量名, n次方数)  # 计算某个张量的n次方<br>
tf.sqrt(张量名)  # 计算某个张量的开方</p>
<pre><code class="language-python">import tensorflow as tf

a = tf.fill([1, 2], 3.)
print(&quot;a:&quot;, a)
print(&quot;a的平方:&quot;, tf.pow(a, 3))
print(&quot;a的平方:&quot;, tf.square(a))
print(&quot;a的开方:&quot;, tf.sqrt(a))

# 运行结果
# a: tf.Tensor([[3. 3.]], shape=(1, 2), dtype=float32)
# a的平方: tf.Tensor([[27. 27.]], shape=(1, 2), dtype=float32)
# a的平方: tf.Tensor([[9. 9.]], shape=(1, 2), dtype=float32)
# a的开方: tf.Tensor([[1.7320508 1.7320508]], shape=(1, 2), dtype=float32)
</code></pre>
</li>
<li>
<p>矩阵乘：tf.matmul</p>
<p>tf.marmul(矩阵1, 矩阵2)  # 实现两个矩阵的相乘</p>
<pre><code class="language-python">import tensorflow as tf

a = tf.ones([3, 2])
b = tf.fill([2, 3], 3.)
print(&quot;a:&quot;, a)
print(&quot;b:&quot;, b)
print(&quot;a*b:&quot;, tf.matmul(a, b))

# 运行结果
# a: tf.Tensor(
# [[1. 1.]
#  [1. 1.]
#  [1. 1.]], shape=(3, 2), dtype=float32)
# b: tf.Tensor(
# [[3. 3. 3.]
#  [3. 3. 3.]], shape=(2, 3), dtype=float32)
# a*b: tf.Tensor(
# [[6. 6. 6.]
#  [6. 6. 6.]
#  [6. 6. 6.]], shape=(3, 3), dtype=float32)
</code></pre>
</li>
</ul>
</li>
<li>
<p>tf.Dataset.from_tensor_slices</p>
<p>将切分传入张量的第一维度，生成输入特征/标签对，构建数据集data = tf.data.Dataset.from_tensor_slices((输入特征, 标签))<br>
(Numpy和Tensor格式都可用该语句读入数据)</p>
<pre><code class="language-python">import tensorflow as tf

features = tf.constant([12, 23, 10, 17])
labels = tf.constant([0, 1, 1, 0])
dataset = tf.data.Dataset.from_tensor_slices((features, labels))
for element in dataset:
    print(element)

# 运行结果
# (&lt;tf.Tensor: shape=(), dtype=int32, numpy=12&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)
# (&lt;tf.Tensor: shape=(), dtype=int32, numpy=23&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)
# (&lt;tf.Tensor: shape=(), dtype=int32, numpy=10&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=1&gt;)
# (&lt;tf.Tensor: shape=(), dtype=int32, numpy=17&gt;, &lt;tf.Tensor: shape=(), dtype=int32, numpy=0&gt;)
</code></pre>
</li>
<li>
<p>tf.GradientTape</p>
<p>with结构记录计算过程，gradient求出张量的梯度</p>
<pre><code class="language-python">with tf.GradientTape() as tape:
	若干个计算过程
grad = tape.gradient(函数, 对谁求导)
</code></pre>
<pre><code class="language-python">import tensorflow as tf

with tf.GradientTape() as tape:
    x = tf.Variable(tf.constant(3.0))
    y = tf.pow(x, 2)
grad = tape.gradient(y, x)
print(grad)

# 运行结果
# tf.Tensor(6.0, shape=(), dtype=float32)
</code></pre>
</li>
<li>
<p>enumerate</p>
<p>enumerate是python的内建函数，它可以遍历每个元素（如列表、元组或字符串），组合为：索引   元素，常在for循环中使用。<br>
enumerate(列表名)</p>
<pre><code class="language-python">seq = ['one', 'two', 'three']
for i, element in enumerate(seq):
    print(i, element)

# 运行结果
# 0 one
# 1 two
# 2 three
</code></pre>
</li>
<li>
<p>tf.one_hot</p>
<p>独热编码（one-hot encodeing）：在分类问题中，常用独热码做标签，标记类别：1表示是，0表示非。<br>
(0狗尾草鸢尾   1杂色鸢尾  2佛吉尼亚鸢尾)<br>
标签：     1<br>
独热码：(0.            1.            0.)</p>
<pre><code class="language-python">import tensorflow as tf

classes = 3
labels = tf.constant([1, 0, 2])  # 输入的元素值最小为0，最大为2
output = tf.one_hot(labels, depth=classes)
print(&quot;result of labels1:&quot;, output)
print(&quot;\n&quot;)

# 运行结果
# result of labels1: tf.Tensor(
# [[0. 1. 0.]
#  [1. 0. 0.]
#  [0. 0. 1.]], shape=(3, 3), dtype=float32)
</code></pre>
</li>
<li>
<p>tf.nn.softmax</p>
<figure data-type="image" tabindex="2"><img src="https://images.cnblogs.com/cnblogs_com/ache/1998711/o_2107111240411-2.png" alt="image-20210710144018858" loading="lazy"></figure>
<p>当n分类的n个输出$$(y_0,y_1,...,y_{n-1})$$通过softmax()函数，便符合概率分布了。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mi>P</mi><mo>(</mo><mi>X</mi><mo>=</mo><mi>x</mi><mo>)</mo><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">且</mi><munder><mo>∑</mo><mi>x</mi></munder><mi>P</mi><mo>(</mo><mi>X</mi><mo>=</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\forall x  P(X=x)\in[0,1]且\sum_x P(X=x)=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∀</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3000100000000003em;vertical-align:-1.250005em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">且</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8999949999999999em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.250005em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<pre><code class="language-python">import tensorflow as tf

y = tf.constant([1.01, 2.01, -0.66])
y_pro = tf.nn.softmax(y)

print(&quot;After softmax, y_pro is:&quot;, y_pro)  # y_pro 符合概率分布

print(&quot;The sum of y_pro:&quot;, tf.reduce_sum(y_pro))  # 通过softmax后，所有概率加起来和为1

# 运行结果
# After softmax, y_pro is: tf.Tensor([0.25598174 0.69583046 0.0481878 ], shape=(3,), dtype=float32)
# The sum of y_pro: tf.Tensor(1.0, shape=(), dtype=float32)
</code></pre>
</li>
<li>
<p>assign_sub</p>
<p>赋值操作，更新参数的值并返回。<br>
调用assign_sub前，先用tf.Variable定义变量w为可训练(可自更新)。<br>
w.assign_sub(w要自减的内容)</p>
<pre><code class="language-python">import tensorflow as tf

x = tf.Variable(4)
x.assign_sub(1)
print(&quot;x:&quot;, x)  # 4-1=3

# 运行结果
# x: &lt;tf.Variable 'Variable:0' shape=() dtype=int32, numpy=3&gt;
</code></pre>
</li>
<li>
<p>tf.argmax</p>
<p>返回张量沿指定维度最大值的索引<br>
tf.argmax(张量名, axis=操作轴)</p>
<pre><code class="language-python">import numpy as np
import tensorflow as tf

test = np.array([[1, 2, 3], [2, 3, 4], [5, 4, 3], [8, 7, 2]])
print(&quot;test:\n&quot;, test)
print(&quot;每一列的最大值的索引：&quot;, tf.argmax(test, axis=0))  # 返回每一列最大值的索引
print(&quot;每一行的最大值的索引&quot;, tf.argmax(test, axis=1))  # 返回每一行最大值的索引

# 运行结果
# 每一列的最大值的索引： tf.Tensor([3 3 1], shape=(3,), dtype=int64)
# 每一行的最大值的索引 tf.Tensor([2 2 0 0], shape=(4,), dtype=int64)
</code></pre>
</li>
</ul>
<h3 id="15-鸢尾花数据集读入">1.5 鸢尾花数据集读入</h3>
<ul>
<li>
<p>数据集介绍</p>
<p>共有数据150组，每组包括花萼长、花萼宽、花瓣长、花瓣宽4个输入特征。同时给出了，这一组特征对应的鸢尾花类别。类别包括Setosa Iris（狗尾草鸢尾），Versicolour Iris（杂色鸢尾），Virginica Iris（弗吉尼亚鸢尾）三类，分别用数字0，1，2表示。</p>
</li>
<li>
<p>从sklearn包datasets读入数据集，语法为：</p>
<pre><code class="language-python">from sklearn.datasets import load_iris
x_data = datasets.load_iris().data  # 返回iris数据集所有输入特征
y_data = datasets.load_iris().target  # 返回iris数据集所有标签
</code></pre>
</li>
<li>
<p>完整的代码</p>
<pre><code class="language-python">from sklearn import datasets
from pandas import DataFrame
import pandas as pd

x_data = datasets.load_iris().data  # .data返回iris数据集所有输入特征
y_data = datasets.load_iris().target  # .target返回iris数据集所有标签
print(&quot;x_data from datasets: \n&quot;, x_data)
print(&quot;y_data from datasets: \n&quot;, y_data)

x_data = DataFrame(x_data, columns=['花萼长度', '花萼宽度', '花瓣长度', '花瓣宽度'])  # 为表格增加行索引（左侧）和列标签（上方）
pd.set_option('display.unicode.east_asian_width', True)  # 设置列名对齐
print(&quot;x_data add index: \n&quot;, x_data)

x_data['类别'] = y_data  # 新加一列，列标签为‘类别’，数据为y_data
print(&quot;x_data add a column: \n&quot;, x_data)

#类型维度不确定时，建议用print函数打印出来确认效果

# 运行结果
# x_data from datasets:
#  [[5.1 3.5 1.4 0.2]
#  [4.9 3.  1.4 0.2]
#  [4.7 3.2 1.3 0.2]
#  [4.6 3.1 1.5 0.2]
#  [5.  3.6 1.4 0.2]
#  ... ...
# y_data from datasets:
#  [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
#  0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
#  1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
#  2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
#  2 2]
#
# x_data add a column: 
#       花萼长度  花萼宽度  花瓣长度  花瓣宽度  类别
# 0         5.1       3.5       1.4       0.2     0
# 1         4.9       3.0       1.4       0.2     0
# 2         4.7       3.2       1.3       0.2     0
# 3         4.6       3.1       1.5       0.2     0
# 4         5.0       3.6       1.4       0.2     0
# ..        ...       ...       ...       ...   ...
# 145       6.7       3.0       5.2       2.3     2
# 146       6.3       2.5       5.0       1.9     2
# 147       6.5       3.0       5.2       2.0     2
# 148       6.2       3.4       5.4       2.3     2
# 149       5.9       3.0       5.1       1.8     2
#
# [150 rows x 5 columns]
</code></pre>
</li>
</ul>
<h3 id="16-神经网络实现鸢尾花分类">1.6 神经网络实现鸢尾花分类</h3>
<ol>
<li>准备数据</li>
</ol>
<ul>
<li>数据集读入</li>
<li>数据集乱序</li>
<li>生成训练集和测试集 (即x_train / y_train, x_test / y_test)</li>
<li>配成（输入特征，标签）对，每次读入一小撮（batch）</li>
</ul>
<ol start="2">
<li>搭建网络
<ul>
<li>定义神经网络中所有可训练参数</li>
</ul>
</li>
<li>参数优化
<ul>
<li>嵌套循环迭代，with结构更新参数，显示当前loss</li>
</ul>
</li>
<li>测试效果
<ul>
<li>计算当前参数前向传播后的准确率，显示当前acc</li>
</ul>
</li>
<li>acc / loss 可视化</li>
</ol>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
# 利用鸢尾花数据集，实现前向传播、反向传播，可视化loss曲线

# 导入所需模块
import tensorflow as tf
from sklearn import datasets
from matplotlib import pyplot as plt
import numpy as np

# 导入数据，分别为输入特征和标签
x_data = datasets.load_iris().data
y_data = datasets.load_iris().target

# 随机打乱数据（因为原始数据是顺序的，顺序不打乱会影响准确率）
# seed: 随机数种子，是一个整数，当设置之后，每次生成的随机数都一样（为方便教学，以保每位同学结果一致）
np.random.seed(116)  # 使用相同的seed，保证输入特征和标签一一对应
np.random.shuffle(x_data)
np.random.seed(116)
np.random.shuffle(y_data)
tf.random.set_seed(116)

# 将打乱后的数据集分割为永不相见的训练集和测试集，训练集为前120行，测试集为后30行
x_train = x_data[:-30]
y_train = y_data[:-30]
x_test = x_data[-30:]
y_test = y_data[-30:]

# 转换x的数据类型，否则后面矩阵相乘时会因数据类型不一致报错
x_train = tf.cast(x_train, tf.float32)
x_test = tf.cast(x_test, tf.float32)

# from_tensor_slices函数使输入特征和标签值一一对应。（把数据集分批次，每个批次batch组数据）
train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)
test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)

# 生成神经网络的参数，4个输入特征故，输入层为4个输入节点；因为3分类，故输出层为3个神经元
# 用tf.Variable()标记参数可训练
# 使用seed使每次生成的随机数相同（方便教学，使大家结果都一致，在现实使用时不写seed）
w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1))
b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1))

lr = 0.1  # 学习率为0.1
train_loss_results = []  # 将每轮的loss记录在此列表中，为后续画loss曲线提供数据
test_acc = []  # 将每轮的acc记录在此列表中，为后续画acc曲线提供数据
epoch = 500  # 循环500轮
loss_all = 0  # 每轮分4个step，loss_all记录四个step生成的4个loss的和

# 训练部分
for epoch in range(epoch):  #数据集级别的循环，每个epoch循环一次数据集
    for step, (x_train, y_train) in enumerate(train_db):  #batch级别的循环 ，每个step循环一个batch
        with tf.GradientTape() as tape:  # with结构记录梯度信息
            y = tf.matmul(x_train, w1) + b1  # 神经网络乘加运算
            y = tf.nn.softmax(y)  # 使输出y符合概率分布（此操作后与独热码同量级，可相减求loss）
            y_ = tf.one_hot(y_train, depth=3)  # 将标签值转换为独热码格式，方便计算loss和accuracy
            loss = tf.reduce_mean(tf.square(y_ - y))  # 采用均方误差损失函数mse = mean(sum(y-out)^2)
            loss_all += loss.numpy()  # 将每个step计算出的loss累加，为后续求loss平均值提供数据，这样计算的loss更准确
        # 计算loss对各个参数的梯度
        grads = tape.gradient(loss, [w1, b1])

        # 实现梯度更新 w1 = w1 - lr * w1_grad    b = b - lr * b_grad
        w1.assign_sub(lr * grads[0])  # 参数w1自更新
        b1.assign_sub(lr * grads[1])  # 参数b自更新

    # 每个epoch，打印loss信息
    print(&quot;Epoch {}, loss: {}&quot;.format(epoch, loss_all/4))
    train_loss_results.append(loss_all / 4)  # 将4个step的loss求平均记录在此变量中
    loss_all = 0  # loss_all归零，为记录下一个epoch的loss做准备

    # 测试部分
    # total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0
    total_correct, total_number = 0, 0
    for x_test, y_test in test_db:
        # 使用更新后的参数进行预测
        y = tf.matmul(x_test, w1) + b1
        y = tf.nn.softmax(y)
        pred = tf.argmax(y, axis=1)  # 返回y中最大值的索引，即预测的分类
        # 将pred转换为y_test的数据类型
        pred = tf.cast(pred, dtype=y_test.dtype)
        # 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型
        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)
        # 将每个batch的correct数加起来
        correct = tf.reduce_sum(correct)
        # 将所有batch中的correct数加起来
        total_correct += int(correct)
        # total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数
        total_number += x_test.shape[0]
    # 总的准确率等于total_correct/total_number
    acc = total_correct / total_number
    test_acc.append(acc)
    print(&quot;Test_acc:&quot;, acc)
    print(&quot;--------------------------&quot;)

# 绘制 loss 曲线
plt.title('Loss Function Curve')  # 图片标题
plt.xlabel('Epoch')  # x轴变量名称
plt.ylabel('Loss')  # y轴变量名称
plt.plot(train_loss_results, label=&quot;$Loss$&quot;)  # 逐点画出trian_loss_results值并连线，连线图标是Loss
plt.legend()  # 画出曲线图标
plt.show()  # 画出图像

# 绘制 Accuracy 曲线
plt.title('Acc Curve')  # 图片标题
plt.xlabel('Epoch')  # x轴变量名称
plt.ylabel('Acc')  # y轴变量名称
plt.plot(test_acc, label=&quot;$Accuracy$&quot;)  # 逐点画出test_acc值并连线，连线图标是Accuracy
plt.legend()
plt.show()

# 运行结果
# --------------------------
# Epoch 498, loss: 0.03232626663520932
# Test_acc: 1.0
# --------------------------
# Epoch 499, loss: 0.032300274819135666
# Test_acc: 1.0
# --------------------------
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://perfectqing.github.io/blogs/tag/S2mqBZ0HP/" class="tag">
                    TensorFlow 笔记
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://perfectqing.github.io/blogs/post/Deep Reinforcement Learning in a Handful of Trials using Probabilistic Dynamics Models/">
                  <h3 class="post-title">
                    Deep Reinforcement Learning in a Handful of Trials using Probabilistic Dynamics Models
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
